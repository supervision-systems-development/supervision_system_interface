
*** Definition of Node types ***
fmod NTYPE is
  --- Definition of the node type, enumerated data type that can have one of four values corresponding to one of four node types. 
  sort NType .
  ops nseq nand nor nxor : -> NType [ctor] .

endfm

*** Definition of execution status ***
fmod STATUS is
  --- Definition of the execution status - component of the configuration. 
  sort Status .
  ops starting correct incorrect executing  : -> Status [ctor] .

endfm

*** Definition of a Graph ***
fmod GRAPH is
  pr NAT .
  pr INT .
  pr STRING .
  pr NTYPE .
  pr STATUS .

  --- Definition of a Graph
  sort Graph .
  op nil : -> Graph [ctor] . --- There was no [ctor]
  op _;;_ : Graph Graph -> Graph [assoc comm id: nil prec 50 ] .

  *** A Graph is conformed by Arcs and Nodes ***

  --- Definition of Nodes
  sort Node .
  op (n[_]:_) : Int NType -> Node [ctor prec 30] . --- Definition of Node. Has Id and Type

  --- Definition of Arcs
  sort Arc .
  subsort Arc < Graph .
  op _->_ : Node Node -> Arc [ctor prec 30] . --- Definition of Arc. Unites two nodes.


  --- Definition of Actions
  sort Action .
  subsort Action < ActionList . --- List of Nodes should be part of Graph
  op (a(_)) : Int -> Action [ctor prec 30] . --- Definition of Action. Has Id

  --- Definition of a List of Actions
  sort ActionList .
  subsort ActionList < Graph . --- List of Nodes should be part of Graph
  op nil : -> ActionList [ctor] . --- Definition of List of Nodes. There was no [ctor] --- it was returning an error
  op _;_ : ActionList ActionList -> ActionList [assoc id: nil] .

  
  var i j x y z : Int .
  var tuple1 tuple2 tuple3 : Tuple .
  var TList TList1 TList2 TList3 : TupleList .
  var AList1 : ActionList .

  --- Definition of a tuple
  sort Tuple .
  subsort Tuple < TupleList .
  op t(_,_) : Int Int -> Tuple [ctor] .

  --- Definition of a list of tuples
  sort TupleList .
  op nil : -> TupleList [ctor] .
  op _,_ : TupleList TupleList -> TupleList [assoc id: nil] .
  
  
endfm

*** Initial configurations ***
fmod CONFIG is
  pr GRAPH .
  --- Definition of the configuration.
  --- Contains all elements of the configuration. 
  sort Config .
  op _|_|_|_|_|_ : ActionList TupleList ActionList ActionList Graph Status -> Config [ctor] . 
  
  *** Variables ***
  var AList CList EList InputActionList : ActionList .
  var TupleCookies TList1 : TupleList .
  var G : Graph .
  var type : NType .
  var i : Int .

endfm

fmod GRAPH-EQ is
  pr CONFIG .
  pr EXT-BOOL .

  *** Variables ***
  var AList AList' AList1 AList2 InputActionList : ActionList . --- Lists of user actions
  var TupleCookies TupleCookies' TupleCookies1 TupleCookies2 : TupleList . --- Lists of Tuple
  var CList CList' CList1 CList2 : ActionList . --- Lists of correct actions
  var EList EList' EList1 EList2 : ActionList . --- Lists of incorrect actions
  var G G' G1 G2 : Graph . --- Graphs
  var type type' type1 type2 type3 : NType . --- Node types
  var i j x y z c n : Int . --- Node ids
  var status status' : Status . --- Status of the execution
  var tuple1 tuple2 tuple3 tuple4 : Tuple . --- tuple variables
  var TList TList1 TList2 TList3 TList4 : TupleList . --- tuple list
  var Action Action1 Action2 : Action .
  var Bool1 Bool2 Bool3 Bool4 : Bool .
  var Node1 Node2 Node3 : Node .

  *** Equations ***

  --- Check if node corresponding to the action is type "sequential", "and", "or" or "xor"
  --- @param Action   the action.
  --- @param Graph    the grah.
  --- @returns String the type of the corresponding node. 
  op checkType : Action Graph -> String .
  eq checkType((a(i)), (n[x]: type') -> (n[i]: type) ;; G) =
    if type == nand
    then "and"
    else 
      if type == nor
      then "or"
      else
        if type == nxor
        then "xor"
        else "seq"
        fi
      fi
    fi .


  --- Checks, whether the node is a starting node. 
  --- @param Action action that needs to be assessed on its startingness.
  --- @return Bool  boolean indicating whether it is a starting node
  op isStartingNode : Action -> Bool . 
  eq isStartingNode( a(i) ) = 
  	if i == (-5)
    then true
    else false
    fi .
  eq isStartingNode( Action1 ) = false [owise] .
    
  --- Checks the action function indicating whether it is a starting action or an ending action or neither.
  --- @param Action   the action that needs to checked.
  --- @return String  the string indicating whether it is a starting ("start"), ending ("fin") or neither ("oth") action. 
  op checkFunc : Action -> String .
  eq checkFunc((a(i))) =
    if i == (-5)
    then "start"
    else 
      if i == (-7)
      then "fin"
      else "oth"
      fi
    fi .

  --- Checks if the node corresponding to the action has the type "and". 
  --- @param Action   the action that needs to be checked.
  --- @param Graph    the graph that contains the corresponding node.
  --- @returns Bool   indication of the type being "and" or not. 
  op isAnd : Action Graph -> Bool .
  eq isAnd((a(i)), G) =
    if checkType((a(i)), G) == "and" 
    then true
    else false
    fi .

  --- Checks if the node corresponding to the action has the type "or". 
  --- @param Action   the action that needs to be checked.
  --- @param Graph    the graph that contains the corresponding node.
  --- @returns Bool   indication of the type being "or" or not. 
  op isOr : Action Graph -> Bool .
  eq isOr((a(i)), G) =
    if checkType((a(i)), G) == "or"
    then true
    else false
    fi .

  --- Checks if the node corresponding to the action has the type "xor". 
  --- @param Action   the action that needs to be checked.
  --- @param Graph    the graph that contains the corresponding node.
  --- @returns Bool   indication of the type being "xor" or not. 
  op isXor : Action Graph -> Bool .
  eq isXor((a(i)), G) =
    if checkType((a(i)), G) == "xor"
    then true
    else false
    fi .

  --- Checks if the node corresponding to the action has the type "seq". 
  --- @param Action   the action that needs to be checked.
  --- @param Graph    the graph that contains the corresponding node.
  --- @returns Bool   indication of the type being "seq" or not. 
  op isSeq : Action Graph -> Bool .
  eq isSeq((a(i)), G) =
    if checkType((a(i)), G) == "seq"
    then true
    else false
    fi .
    

  --- Provides the list of actions corresponding to parent nodes of the node corresponding to the input action. 
  --- @param Action         the action.
  --- @param Graph          the graph.
  --- @returns ActionList   the list of actions.
  op parents : Action Graph -> ActionList .
  eq parents((a(i)), (n[x]: type1) -> (n[i]: type) ;; G) =
    (a(x)) ; parents((a(i)), G) .
  eq parents((a(i)), G) = nil [owise] .

  --- Provides the list of actions corresponding to child nodes of the node corresponding to the action in the argument.
  --- @param Action       the action.
  --- @param Graph        the graph.
  --- @returns ActionList the list of actions. 
  op children : Action Graph -> ActionList .
  eq children((a(i)), (n[i]: type) -> (n[x]: type') ;; G) =
    (a(x)) ; children((a(i)), G) .
  eq children((a(i)), G) = nil [owise] .
  

  --- Provides a list of actions corresponding to child nodes of the node corresponding to the input action.
  --- @param ActionList     the list of actions.
  --- @param Graph          the graph.
  --- @returns ActionsList  the list of actions corresponding to child nodes. 
  op listChildren : ActionList Graph -> ActionList . 
  eq listChildren( ( Action ; AList1 ) , G ) = ( ( children(Action, G) ) ; listChildren( AList1 , G ) ) .
  eq listChildren( nil, G ) = nil .
   

  --- Checks if the action is in the list of actions.
  --- @param Action     the action.
  --- @param ActionList the list of actions.
  --- @returns Bool     the indication whether the action is in the list of actions. 
  op _in_ : Action ActionList -> Bool .
  eq (a(i)) in (AList1 ; (a(i)) ; AList2) = true .
  eq (a(i)) in AList1 = false [owise] .
  

  --- Checks if a tuple is in a list of tuples.
  --- @param Tuple      the tuple.
  --- @param TupleList  the list of tuples.
  --- @returns Bool     indication whether the tuple is in the list of tuples.
  op tupleInTupleList : Tuple TupleList -> Bool .
  eq tupleInTupleList( ( t( x , y ) ) , ( t( z , i) , TList1 ) ) = 
  if ( x == z ) and ( y == i ) then true
  else tupleInTupleList( ( t( x , y ) ) , TList1)
  fi .
  eq tupleInTupleList(tuple2, TList2) = false [owise] .

  --- Removes a tuple from the list of tuples.
  --- @param Tuple        the tuple.
  --- @param TupleList    the list of tuples.
  --- @returns TupleList  the modified list of tuples.
  op removeTupleFromTupleList : Tuple TupleList -> TupleList .
  eq removeTupleFromTupleList( tuple1 , ( TList1 , tuple1 , TList2 ) ) = ( TList1 , TList2 ) .
  

  --- Activates an action indicator by setting its value to 1.
  --- @param Int        label of the action.
  --- @param TupleList  list of indicators.
  --- @return TupleList list of indicators with activated action. 
  op activateCookie : Int TupleList -> TupleList .
  eq activateCookie( x , TList ) = 
  if tupleInTupleList( t( x , 1 ) , TList ) then 
    TList
    else 
      if tupleInTupleList( t( x , (-1) ) , TList ) then 
      TList
        else ( TList , t( x , 1 ) )
      fi
  fi .
  

  --- Blocks the action in the list of indicators by setting the indicator for the action to -1.
  --- @param Int          label of the action.
  --- @param TupleList    list of indicators.
  --- @returns TupleList  modified list of indicators.
  op blockCookie : Int TupleList -> TupleList .
  eq blockCookie( x , TList ) = 
  if tupleInTupleList( t( x , -1 ) , TList ) then 
    TList
    else 
	 if tupleInTupleList( t( x , 1 ) , TList) then blockCookie( x , removeTupleFromTupleList( t( x , 1 ) , TList ) ) 
	 else 
	  ( TList , t( x , -1 ) ) 	
	 fi
  fi .
   

  --- Checks whether the action is activated (has its corresponding value set to 1 in the list of indicators)
  --- @param Int        the label of the action.
  --- @param TupleList  the list of indicators.
  --- @returns  Bool    the indication whether the action is active in the list of indicators.
  op isCookieActive : Int TupleList -> Bool .
  eq isCookieActive( x , TList ) =
  if tupleInTupleList ( t( x , 1 ) , TList ) then true
  else false
  fi .
  
  --- Checks whether the action is blocked (has its corresponding value set to -1 in the list of indicators)
  --- @param Int        the label of the action.
  --- @param TupleList  the list of indicators.
  --- @returns Bool     the indication whether the action is actually blocked. 
  op isCookieBlocked : Int TupleList -> Bool .
  eq isCookieBlocked( x , TList ) =
  if tupleInTupleList ( t( x , -1 ) , TList ) then true
  else false
  fi .
  
  
  --- Resets the indicator for the label of the action in the list of indicators.
  --- @param Int        the label of the action.
  --- @param TupleList  the list of indicators.
  --- @return TupleList the modified list of indicators.
  op resetCookie : Int TupleList -> TupleList .
  eq resetCookie( x , TList ) = 
  if tupleInTupleList( ( t( x , 1 ) ) , TList ) then 
  	if  tupleInTupleList( ( t( x , -1 ) ) , TList ) then removeTupleFromTupleList( t( x , 1 )  , removeTupleFromTupleList( t( x , -1 )  , TList ) )
  		else 
        	removeTupleFromTupleList( t( x , 1 )  , TList)
    fi
  else
  	if  tupleInTupleList( ( t( x , -1 ) ) , TList ) then removeTupleFromTupleList( t( x , -1 )  , TList )
  		else 
        	TList
    fi
  fi .


  --- Resets indicators for the actions in the first list in the list of indicators.
  --- @param ActionList   the list of actions. 
  --- @param TupleList    the list of indicators. 
  --- @returns TupleList  the modified list of indicators. 
  op resetActionCookies : ActionList TupleList -> TupleList .
  eq resetActionCookies( ( a(x) ; AList1 ) , TList ) = resetActionCookies(AList1 , resetCookie(x, TList)) .
  eq resetActionCookies( nil , TList ) = TList .
  

  --- Check if there is an edge between nodes corresponding to actions actions. 
  --- @param Action the first action.
  --- @param Action the second action.
  --- @param Graph  the graph.
  --- @returns Bool the indication of the edge existing.
  op isArcAction : Action Action Graph -> Bool .
  eq isArcAction( a(x), a(y) , nil) = false .
  eq isArcAction( a(x), a(y) , G1 ;; (n[x]: type1) -> (n[y]: type) ;; G2) = true .
  eq isArcAction( a(x), a(y) , G) = false [owise] .
  
  
  --- Checks whether the action in the second argument is present in a subgraph starting from first action.
  --- @param Action       the action that the subgraphs starts from.
  --- @param Action       the action that the subgraph ends in.
  --- @param ActionList   the list of actions containing actions that the subgraphs of have been checked. 
  --- @param Graph        the graph that may contain the subgraph.
  --- @param TupleList    the list of indicators. 
  --- @returns ActionList the list of actions.
  op DFS3 : Action Action ActionList Graph TupleList -> ActionList .
  eq DFS3( a(i) , a(i) , AList , G , TList1 ) = ( a(i) ; AList ) .
  eq DFS3( a(i) , a(n) , AList , G , TList1 ) = 
  if ( a(i) in AList ) then
  	nil
  else
  		forAllChildren3( children(a(i), G) , a(n) , ( a(i) ; AList ) , G , TList1 )
  fi .
        
  --- Performs subgraph search on the list of actions.
  --- @param ActionList     list of actions.
  --- @param Action         the action that is being searhced.
  --- @param ActionList     list of already checked actions.
  --- @param Graph          the graph that may contain the subgraph.
  --- @param TupleList      the list of indicators.
  --- @return ActionList    the list of actions.
  op forAllChildren3 : ActionList Action ActionList Graph TupleList -> ActionList .
  eq forAllChildren3( ( a(x) ; AList ) , a(n) , AList1 , G , TList1 ) = ( ( DFS3( a(x) , a(n) , AList1 , G , TList1 ) ) ; ( forAllChildren3( AList , a(n) , AList1 , G , TList1 ) ) ) .
  eq forAllChildren3( nil , a(n) , AList1 , G , TList1 ) = nil .
    

  --- Detects a subgraph form action in first argument to action in second argument in graph in third argument. 
  --- @param Action     the action from which the subgraph begins.
  --- @param Action     the action which the subgraph reaches. 
  --- @param Graph      the graph in which the subgraph may appear.
  --- @param TupleList  the list of indicators.
  --- @returns Bool     indication whether the second action is in a subgraph
  op enteringLoop : Action Action Graph TupleList -> Bool .
  eq enteringLoop( Action1 , Action2 , G , TList1 ) =
  if ( DFS3( Action1 , Action2 , nil , G , TList1 ) == nil )
  	then false
  else 
  	if ( isArcAction( Action1 , Action2 , G ) )
    	then true
    else false
    fi
  fi .
  eq enteringLoop( nil , Action2 , G , TList1 ) = false .
  eq enteringLoop( Action1 , nil , G , TList2 ) = true .
  

  --- Collects actions that are in any subgraph from action in the first argument to action in the second argument in the graph in the third argument.
  --- @param Action       the first action.
  --- @param Action       the second action.
  --- @param Graph        the graph.
  --- @param TupleList    the list of indicators. 
  --- @returns ActionList the list of actions. 
  op getActionsForLoopDeactivation : Action Action Graph TupleList -> ActionList .
  eq getActionsForLoopDeactivation( a(x) , a(y) , G , TList1 ) =
  if isArcAction( a(x) , a(y) , G ) 
  	then
  		(  removeDuplicates( DFS3( a(y) , a(x) , nil , G , TList1 ) )  ) 
  else nil 
  fi . 
  eq getActionsForLoopDeactivation( Action1 , Action1 , G , TList1 ) = nil [owise] .

  --- Places every action from first list of actions into second list of actions in case the action is not already in the second list.
  --- @param ActionList   the list of actions.
  --- @param ActionList   the second list of actions.
  --- @returns ActionList the modified list of actions.  
  op removeDuplicatesHelper : ActionList ActionList -> ActionList .
  eq removeDuplicatesHelper((Action1 ; AList1) , AList2) = 
  if (Action1 in AList2) then removeDuplicatesHelper(AList1, AList2) else removeDuplicatesHelper(AList1, (Action1 ; AList2)) fi .
  eq removeDuplicatesHelper(nil, AList2) = AList2 .


  --- Removes duplicate actions.
  --- @param ActionList   the list of actions.
  --- @returns ActionList the modified list of actions. 
  op removeDuplicates : ActionList -> ActionList .
  eq removeDuplicates(AList1) = removeDuplicatesHelper(AList1, nil) .
 

  --- Returns the last (rightmost) action of an ActionList list of actions. 
  --- @param ActionList   the list of actions.
  --- @returns Action     the last (rightmost) action in the list.   
  op lastAction : ActionList -> Action .
  eq lastAction( ( AList1 ; Action1 ) ) = Action1 .
  eq lastAction(nil) = nil .
  

  --- Checks if the action does not have its corresponding indicator activated (set to 1) in the list of indicators. 
  --- @param Int       the label of the action.
  --- @param TupleList the list of indicators.
  --- @returns Bool    indication of the fulfillment of the requirement. 
  op isCookieNotActive : Int TupleList -> Bool .
  eq isCookieNotActive( x , TList ) =
  if tupleInTupleList ( t( x , 1 ) , TList ) then false
  else true
  fi .
  

  --- Checks if the action does not have its corresponding indicator blocked (set to -1) in the list of indicators. 
  --- @param Int       the label of the action.
  --- @param TupleList the list of indicators.
  --- @returns Bool    indication of the fulfillment of the requirement.
  op isCookieNotBlocked : Int TupleList -> Bool .
  eq isCookieNotBlocked( x , TList ) =
  if tupleInTupleList ( t( x , -1 ) , TList ) then false
  else true
  fi .
  

  --- Checks whether all actions in the list of actions are active. 
  --- @param ActionList   the lsit of actions.
  --- @param TupleList    the list of indicators
  --- @param Graph        the graph.
  --- @returns Bool       the indication whether all indicators for all actions are activated.
  op allParentCookiesActiveHelper : ActionList TupleList Graph -> Bool .
  eq allParentCookiesActiveHelper( ( a(i) ; AList1 ) , TList1 , G ) = isCookieActive( i , TList1 ) and allParentCookiesActiveHelper( AList1 , TList1, G ) .
  eq allParentCookiesActiveHelper( nil, TList1, G ) = true .
  
  --- Checks whether all indicators of all parent nodes of the node corresponding to the input action are activated. 
  --- @param Action     the action that needs its corresponding parent nodes checked.
  --- @param TupleList  the list of indicators.
  --- @param Graph      the graph.
  --- @returns Bool     indication whether the requirement is satisfied. 
  op allParentCookiesActive : Action TupleList Graph -> Bool .
  eq allParentCookiesActive( a(i) , TList1 , G ) = allParentCookiesActiveHelper( parents(a(i) , G ) , TList1 , G ) .
  eq allParentCookiesActive( Action1 , nil , G ) = false .
  
  

  --- Checks if at least one action has its indicator activated (set to 1).
  --- @param ActionList   the list of actions.
  --- @param TupleList    the list of indicators.
  --- @param Graph        the graph.
  --- @returns Bool       indication whether at least one action corresponding to a parent node is activated. 
  op atLeastOneParentCookieActiveHelper : ActionList TupleList Graph -> Bool .
  eq atLeastOneParentCookieActiveHelper( ( a(i) ; AList1 ) , TList1 , G ) = isCookieActive( i , TList1 ) or atLeastOneParentCookieActiveHelper( AList1 , TList1, G ) .
  eq atLeastOneParentCookieActiveHelper( nil, TList1, G ) = false .
  
  
  --- Checks if at least one parent node of the node corresponding to the action has its indicator activated (set to 1).
  --- @param Action       the action.
  --- @param TupleList    the list of indicators.
  --- @param Graph        the graph.
  --- @returns Bool       indication whether at least one action corresponding to a parent node is activated. 
  op atLeastOneParentCookieActive : Action TupleList Graph -> Bool .
  eq atLeastOneParentCookieActive( a(i) , TList1 , G ) = atLeastOneParentCookieActiveHelper( parents( a(i) , G ) , TList1 , G ) .
  eq atLeastOneParentCookieActive( Action1 , nil , G ) = false .
  
  
  --- Checks whether at least one action corresponding to a parent node of the node corresponding to the action in the first argument is blocked (marked with a -1 value) in the list of indicators. 
  --- @param Action     the action that needs to be checked.
  --- @param TupleList  the list of indicators that may contain the indicator for the action.
  --- @param Graph      the graph containing nodes corresponding to actions. 
  op isAtLeastOneParentBlocked : Action TupleList Graph -> Bool .
  eq isAtLeastOneParentBlocked( a(i) , ( ( t( x , y) ) , TList1 ) , G ) =
  if ( y == -1 ) and ( ( a(x) ) in parents( a(i) , G ) ) then true 
  else isAtLeastOneParentBlocked( a(i) , TList1 , G ) 
  fi .
  eq isAtLeastOneParentBlocked( a(i) , nil , G ) = false .

  --- Checks if the list of actions contains an action corresponding to a node with "XOR" type.
  --- @param ActionList   the list of actions.
  --- @param Graph        the graph. 
  --- @returns Bool       the indication whether the list contains actions correspondign to nodes with "XOR" type
  op isXorInList : ActionList Graph -> Bool .
  eq isXorInList( ( a(i) ; AList1 ) , G ) = isXor( a(i) , G ) or isXorInList(  AList1  , G ) .
  eq isXorInList( nil , G ) = false .
  

  --- Provides a list of actions corresponding to nodes with "XOR" type in the list of actions. 
  --- @param ActionList   the list of actions. 
  --- @param Graph        the graph.
  --- @return ActionList  the list of actions that correspond to nodes with "XOR" type. 
  op getXorListInActionList : ActionList Graph -> ActionList .
  eq getXorListInActionList( ( a(i) ; AList1 ) , G ) = 
  if isXor( a(i) , G ) then ( a(i) ; getXorListInActionList( AList1 , G ) ) else getXorListInActionList( AList1 , G ) fi .
  eq getXorListInActionList( nil , G ) = nil .
  

  --- Blocks all actions in the list of actions by setting the indicators for these actions to -1 in the list of indicators.
  --- @param ActionList     list of actions.
  --- @param TupleList      list of indicators.
  --- @returns TupleList    modified list of indicators.
  op blockActionListCookies : ActionList TupleList -> TupleList .
  eq blockActionListCookies( ( a(i) ; AList1 ) , TList ) = blockActionListCookies( AList1 , blockCookie( i , TList) ) .
  eq blockActionListCookies( nil , TList ) = TList . 
  

  --- Removes an action from a list of actions.
  --- @param Action       the action to be removed.
  --- @param ActionList   the list of actions.
  --- @returns Actionlist the modified list of actions.
  op removeAction : Action ActionList -> ActionList .
  eq removeAction( a(i) , ( a(n) ; AList1 ) ) = if (i == n) then removeAction(a(i) , AList1) else a(n) ; removeAction(a(i) , AList1) fi .
  eq removeAction( a(i) , nil ) = nil .
  
  --- Blocks the action corresponding to the parent node of the node corresponding to the input actions, as well as all actions corresponding to sibling nodes of the node corresponding to the input action.
  --- @param Action      the action.
  --- @param Graph       the graph.
  --- @param TupleList   the list of indicators. 
  --- @returns TupleList the modified list of indicators. 
  op blockParentAndSiblingCookiesIfParentIsXor : Action Graph TupleList -> TupleList . 
  eq blockParentAndSiblingCookiesIfParentIsXor( ( a(i) ) , G , TList ) = 
  if isXorInList( parents( a(i) , G ) , G ) then blockActionListCookies( removeAction( a(i) , listChildren(getXorListInActionList( parents( a(i) , G ) , G ), G ) )  , blockActionListCookies( getXorListInActionList( parents( a(i) , G ) , G ) , TList ) )
  else TList fi .

  
  --- Checks if the node corresponding to the action does not have the type "and"
  --- @param Action   the action.
  --- @param Graph    the graph.
  --- @returns Bool   indication wehther the type of the corresponding node is not "and".
  op isNotAnd : Action Graph -> Bool .
  eq isNotAnd( a(i) , G ) =
  	if not ( checkType( a(i), G ) == "and" ) then true
    else false
    fi .

endfm

mod GRAPH-RL is
  pr GRAPH-EQ .
  inc CONFIG .

  *** Variables ***
  var AList AList' AList1 AList2 CorrectActionList IncorrectActionList InputActionList LR LW List_Of_Input_Actions List_Of_Correct_Actions List_Of_Incorrect_Actions : ActionList . --- Lists of user actions
  var CList CList' CList1 CList2 : ActionList . --- Lists of correct actions
  var TupleCookies TupleCookies' TupleCookies1 TupleCookies2 TupleBCookies TupleBCookies2 TupleBCookies1 TupleBCookies3 CookieT List_Of_Indicators  : TupleList . --- Lists of cookies
  var TuplePossibleCookies TupleRealCookies TupleBlockedCookies : TupleList . 
  var EList EList' EList1 EList2 : ActionList . --- Lists of incorrect actions
  var G G' G1 G2 Pattern : Graph . --- Graphs
  var Node1 Node2 Node3 : Node .
  var type type' type1 type2 type3 : NType . --- Node types
  var i j x y z : Int . --- Node ids
  var status status' Status final_st : Status . --- Status of the execution

  *** Rules ***
  --- Transition rules


  --- Rule handling the starting of the execution.
  --- Start the execution: Transition status from "starting" to "executing" and consume starting action.
  rl [start]: 
    a(i) ; AList | TupleCookies | CList | EList | G | starting  
    => if isStartingNode( a(i) ) then
    AList | activateCookie( i , TupleCookies) | ( CList ; (a(i)) ) | EList | G | executing
	else 
    AList | TupleCookies | CList | ( EList ; (a(i)) ) | G | starting 
    fi .

  --- Rule handling the completion of the execution. 
  --- End the execution: Transition status from "executing" to "correct" or "incorrect".
  rl [end]:  
    nil | TupleCookies | CList | EList | G | executing
    =>
    if checkFunc(lastAction(CList)) == "fin"
    then
      nil | TupleCookies | CList | EList | G | correct 
    else 
      nil | TupleCookies | CList | EList | G | incorrect
    fi .
  
  --- Rule implementing the execution between the start and the completion of the task. 
  rl [step] :
    (a(i)) ; AList | TupleCookies | CList | EList | G | executing
    => 
   if not ( ( isAtLeastOneParentBlocked( a(i) , TupleCookies, G ) ) and ( isCookieBlocked( i , TupleCookies ) ) ) then
     if ( isCookieActive(i, TupleCookies) or isCookieBlocked(i, TupleCookies) ) then
       if enteringLoop( lastAction(CList) , a(i) , G , TupleCookies ) and isCookieNotActive(i, resetActionCookies( getActionsForLoopDeactivation( lastAction(CList) , a(i) , G , TupleCookies ) , TupleCookies ) ) and isCookieNotBlocked( i, resetActionCookies( getActionsForLoopDeactivation( lastAction(CList) , a(i) , G , TupleCookies ) , TupleCookies ) ) then
     		if isAnd((a(i)), G) and allParentCookiesActive( a(i) , TupleCookies , G ) then AList | blockParentAndSiblingCookiesIfParentIsXor( a(i) , G , activateCookie( i , resetActionCookies( getActionsForLoopDeactivation( lastAction(CList) , a(i) , G , TupleCookies ) , TupleCookies ) ) )   | (CList ; (a(i))) | EList | G | executing 
      		else
      			if ( isNotAnd( a(i) , G ) and atLeastOneParentCookieActive( a(i) , TupleCookies , G ) ) then AList | blockParentAndSiblingCookiesIfParentIsXor( a(i) , G , activateCookie( i , resetActionCookies( getActionsForLoopDeactivation( lastAction(CList) , a(i) , G , TupleCookies ) , TupleCookies ) ) )  | (CList ; (a(i))) | EList | G | executing 
        		else
            		AList | TupleCookies | CList | (EList ; (a(i))) | G | executing 
        		fi
      		fi
       else 
       	 AList | TupleCookies | CList | (EList ; (a(i))) | G | executing
       fi
    else
     if ( isCookieNotActive(i, TupleCookies) and isCookieNotBlocked(i , TupleCookies) ) then
      if isAnd((a(i)), G) and allParentCookiesActive( a(i) , TupleCookies , G ) then AList | blockParentAndSiblingCookiesIfParentIsXor( a(i) , G , activateCookie( i , TupleCookies ) )  | (CList ; (a(i))) | EList | G | executing 
      else
      if ( isNotAnd( a(i) , G ) and atLeastOneParentCookieActive( a(i) , TupleCookies , G ) ) then AList | blockParentAndSiblingCookiesIfParentIsXor( a(i) , G , activateCookie( i , TupleCookies ) )  | (CList ; (a(i))) | EList | G | executing 
        else
        	AList | TupleCookies | CList | (EList ; (a(i))) | G | executing 
        fi
      fi
      else AList | TupleCookies | CList | (EList ; (a(i))) | G | executing fi
    fi
   else AList | TupleCookies | CList | (EList ; (a(i))) | G | executing
   fi .
endm
